/*-
 * ========================LICENSE_START=================================
 * TeamApps
 * ---
 * Copyright (C) 2014 - 2022 TeamApps.org
 * ---
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =========================LICENSE_END==================================
 */
class(c) ::= <<
<javaFilePrelude(c.packageName)>

<c.effectiveJavaImports:{im|import <im.javaPackageName>.<im.name>;}; separator="\n">

@JsonTypeName("<c.name>")
@JsonInclude(JsonInclude.Include.NON_NULL)
public <if(c.abstract)>abstract <endif>class <c.javaClassName> <if(c.superClass)>extends <c.superClass.javaClassName> <endif>implements <if(c.interfaces)><c.interfaces:{itf|<itf.javaClassName>}; separator=", ">, <endif>DtoObject {

    public static final String TYPE_ID = "<c.name>";  // TODO remove

	<c.propertiesNotImplementedBySuperClasses:fieldDeclaration(); separator="\n">

	<constructor(c, "", "")>

	<toString(c)>

	<c.propertiesNotImplementedBySuperClasses:getter(); separator="\n\n">

	<c.propertiesNotImplementedBySuperClasses:setter(c.javaClassName); separator="\n\n">

	<c.eventsWithParameters:eventJsonWrapper(); separator="\n\n">

	<c.queries:eventJsonWrapper(); separator="\n\n">

	<c.commands:commandClass(); separator="\n\n">

}>>

interface(c) ::= <<
<javaFilePrelude(c.packageName)>

<c.effectiveJavaImports:{im|import <im.javaPackageName>.<im.name>;}; separator="\n">

@JsonTypeName("<c.name>")
@JsonInclude(JsonInclude.Include.NON_NULL)
public interface <c.javaClassName> extends <if(c.interfaces)><c.interfaces:{si|<si.javaClassName>}; separator=", ">, <endif>DtoObject {

	<c.properties:getterStub(); separator="\n">
	<c.nonRequiredProperties:setterStub(c); separator="\n">

    <c.eventsWithParameters:eventJsonWrapper(); separator="\n\n">

	<c.queries:eventJsonWrapper(); separator="\n\n">

	<c.commands:commandClass(); separator="\n\n">

}>>

javaFilePrelude(packageName) ::= <<
package <packageName>;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.stream.StreamSupport;

import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import org.teamapps.projector.dto.JsonWrapper;
import org.teamapps.projector.dto.DtoObject;
import org.teamapps.projector.session.SessionContext;

import org.teamapps.commons.util.ExceptionUtil;

/**
 * THIS IS GENERATED CODE!
 * PLEASE DO NOT MODIFY - ALL YOUR WORK WOULD BE LOST!
 */
>>

fieldDeclaration(p) ::= <<
protected <p.type.javaTypeString> <p.name>;
>>

getterStub(p) ::= <<
public <p.type.javaTypeString> <if(p.type.boolean)>is<else>get<endif><p.name; format="cap">();
>>

setterStub(p, c) ::= <<
public <c.javaClassName> set<p.name; format="cap">(<p.type.javaTypeString> <p.name>);
>>

constructor(c, classNamePrefix, classNameSuffix) ::= <<
<if(c.allRequiredProperties)>
/**
 * @deprecated Only for Jackson deserialization. Use the other constructor instead.
 */
@Deprecated
public <classNamePrefix><c.name; format="cap"><classNameSuffix>() {
	// default constructor for Jackson
}
<endif>

public <classNamePrefix><c.name; format="cap"><classNameSuffix>(<c.allRequiredProperties:parameter(); separator=", ">) {
	<if(c.superClass)>super(<c.superClass.allRequiredProperties:{p|<p.name>}; separator=", ">);<endif>
	<c.requiredPropertiesNotImplementedBySuperClasses:propertyAssignment(); separator="\n">
}
>>

toString(c) ::= <<
@SuppressWarnings("unchecked")
public String toString() {
	return new StringBuilder(getClass().getSimpleName()).append(": ")
			<c.simplePropertiesSortedByRelevance:propertyToString(); separator=".append(\", \")\n">
			.toString();
}
>>

propertyToString(p) ::= <<
.append(<if(!p.type.isDtoClassOrInterface)>"<p.name>=" + <p.name><else><p.name> != null ? "<p.name>={" + <p.name>.toString() + "}" : ""<endif>)
>>

jsonSetter(p) ::= <<
<! if (<if(p.type.isPrimitiveType)><p.name> != <defaultValue(p)><else>!Objects.equals(<p.name>, <defaultValue(p)>)<endif>) { !><\\>
<if(!p.type.isPrimitiveType)>if (<p.name> != null) {<endif>
<if(!p.type.isPrimitiveType)>	<endif>obj.put("<p.name>", <p.name>);
<if(!p.type.isPrimitiveType)>}<endif>
<! } !>
>>

parameter(p) ::= "<p.type.javaTypeString> <p.name>"

getter(propertyDeclaration) ::= <<
@com.fasterxml.jackson.annotation.JsonGetter("<propertyDeclaration.name>")
public <propertyDeclaration.type.javaTypeString> <if(propertyDeclaration.type.boolean)>is<else>get<endif><propertyDeclaration.name; format="cap">() {
	return <propertyDeclaration.name>;
}
>>

setter(propertyDeclaration, clazzName) ::= <<
@com.fasterxml.jackson.annotation.JsonSetter("<propertyDeclaration.name>")
public <clazzName; format="cap"> set<propertyDeclaration.name; format="cap">(<propertyDeclaration.type.javaTypeString> <propertyDeclaration.name>) {
	<propertyAssignment(propertyDeclaration)>
	return this;
}
>>

propertyAssignment(p) ::= "this.<p.name> = <p.name>;"

enumClass(e) ::= <<
<javaFilePrelude(e.packageName)>
public enum <e.javaClassName> {
	<e.enumConstants:enumConstant(e.stringEnum); separator=",\n">;

	<if(e.stringEnum)>
	private final String jsonValue;

	<e.javaClassName>(String jsonValue) {
		this.jsonValue = jsonValue;
	}

	@com.fasterxml.jackson.annotation.JsonValue
	public String jsonValue() {
		return jsonValue;
	}
	<else>
    @com.fasterxml.jackson.annotation.JsonValue
    public int jsonValue() {
        return ordinal();
    }
	<endif>
}>>


enumConstant(ec, stringEnum) ::= <<
	<ec.Identifier><if(stringEnum)>(<ec.StringLiteral>)<endif>
>>


commandClass(cmd) ::= <<
@JsonTypeName("<cmd.declaringClass.name>.<cmd.name>")
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder({<cmd.allProperties:{p|"<p.name>"}; separator=", ">})
public static class <cmd.name; format="cap">Command {

    public static final String CMD_NAME = "<cmd.name>";

	<cmd.allProperties:fieldDeclaration(); separator="\n">

	<constructor(cmd, "", "Command")>

	<toString(cmd)>

	<cmd.allProperties:getter(); separator="\n\n">

	<cmdParametersGetter(cmd)>

}
>>

cmdParametersGetter(cmd) ::= <<
public Object[] getParameters() {
    return new Object[] {<cmd.allProperties:{p|<p.name>}; separator=", ">};
}
>>

jsonWrapper(c) ::= <<
<javaFilePrelude(c.packageName)>

<c.effectiveJavaImports:{im|import <im.javaPackageName>.<im.name>;}; separator="\n">

public class <c.javaClassName>Wrapper extends <if(c.superClass)><c.superClass.name>Wrapper<else>JsonWrapper<endif> {

    public static final String TYPE_ID = "<c.name>";

    public <c.javaClassName>Wrapper(JsonNode jsonNode) {
        super(jsonNode);
    }

    public <c.javaClassName> unwrap() {
        return ExceptionUtil.runWithSoftenedExceptions(() -> SessionContext.current().getObjectMapper().treeToValue(jsonNode, <c.javaClassName>.class));
    }

    public <c.javaClassName> unwrap(ObjectMapper objectMapper) {
        return ExceptionUtil.runWithSoftenedExceptions(() -> objectMapper.treeToValue(jsonNode, <c.javaClassName>.class));
    }

    <c.properties:jsonWrapperGetter(); separator="\n\n">
}
>>

eventJsonWrapper(c) ::= <<
public static class <c.javaClassName>Wrapper extends JsonWrapper {

    public static final String TYPE_ID = "<c.name>";

    public <c.javaClassName>Wrapper(JsonNode jsonNode) {
        super(jsonNode);
    }

    <c.allProperties:jsonWrapperGetter(); separator="\n\n">
}
>>

jsonWrapperGetter(propertyDeclaration) ::= <<
<uiObjectWrapperGetter(propertyDeclaration)>
>>

uiObjectWrapperGetter(propertyDeclaration) ::= <<
public <propertyDeclaration.type.javaJsonWrapperTypeString> <if(propertyDeclaration.type.boolean)>is<else>get<endif><propertyDeclaration.name; format="cap">() {
    var node = jsonNode.get("<propertyDeclaration.name>");
    <wrapperPropertyValueExtractor(propertyDeclaration.type, "node")>
}
>>

wrapperPropertyValueExtractor(type, variableName) ::= <<
if (<variableName> == null || <variableName>.isNull()) {
    return <type.defaultValue>;
}
<if (type.isClientObjectPointer)>
return SessionContext.current().getClientObjectById(node.get("ref").textValue());
<elseif (type.isList)>
ArrayNode <variableName>ArrayNode = ((ArrayNode) <variableName>);
return StreamSupport.stream(Spliterators.spliterator(<variableName>ArrayNode.elements(), <variableName>ArrayNode.size(), Spliterator.ORDERED), false)
    .map(<variableName>X -> {
        <wrapperPropertyValueExtractor(type.collectionType, [variableName,"X"])>
    })
    .collect(Collectors.toList());
<elseif (type.isDictionary)>
ObjectNode <variableName>ArrayNode = ((ObjectNode) <variableName>);
return StreamSupport.stream(Spliterators.spliterator(<variableName>ArrayNode.fields(), <variableName>ArrayNode.size(), Spliterator.ORDERED), false)
        .collect(Collectors.toMap(e -> e.getKey(), <variableName>Field -> {
            JsonNode <variableName>X = <variableName>Field.getValue();
            <wrapperPropertyValueExtractor(type.collectionType, [variableName,"X"])>
        }));
<elseif (type.isDtoClassOrInterface)>
if (!<variableName>.isObject()) {
    throw new IllegalArgumentException("<variableName> must be an object!");
}
// <type.text>
return new <type.javaJsonWrapperTypeString>(<variableName>);
<elseif (type.isEnum)>
if (<variableName>.isInt()) {
    return <type.javaTypeString>.values()[<variableName>.intValue()];
} else if (<variableName>.isTextual()) {
    return <type.javaTypeString>.valueOf(<variableName>.textValue());
} else {
    return null;
}
<elseif (type.isString)>
return <variableName>.textValue();
<elseif (type.isPrimitiveOrWrapperType)>
return <variableName>.as<type.primitiveTypeName; format="cap">();
<elseif (type.isObjectOrObjectCollection)>
return new JsonWrapper(node);
<else>
if (!<variableName>.isObject()) {
    throw new IllegalArgumentException("<variableName> must be an object!");
}
return new <type.javaJsonWrapperTypeString>(<variableName>);
<endif>
>>

clientObjectChannel(c) ::= <<
<javaFilePrelude(c.packageName)>

<c.effectiveJavaImports:{im|import <im.javaPackageName>.<im.name>;}; separator="\n">
import org.teamapps.projector.clientobject.ClientObjectChannel;

public class <c.name>ClientObjectChannel implements ClientObjectChannel {

    private final ClientObjectChannel delegate;

	public <c.name>ClientObjectChannel(ClientObjectChannel clientObjectChannel) {
        this.delegate = clientObjectChannel;
	}

	@Override
    public void forceRender() {
        delegate.forceRender();
    }

    @Override
    public boolean isRendered() {
        return delegate.isRendered();
    }

	@Override
    public boolean sendCommandIfRendered(String name, Object[] params, Consumer\<JsonWrapper\> resultHandler) {
        return delegate.sendCommandIfRendered(name, params, resultHandler);
    }

	<c.allCommands:commandClientObjectChannelMethod(); separator="\n\n">

    @Override
    public void toggleEvent(String eventName, boolean enabled) {
        delegate.toggleEvent(eventName, enabled);
    }

	<c.allEvents:toggleEventMethod(); separator="\n\n">

}>>

commandClientObjectChannelMethod(cmd) ::= <<
public boolean <cmd.name>(<cmd.allProperties:parameter(); separator=", ">) {
    return this.delegate.sendCommandIfRendered("<cmd.name>", new Object[] { <cmd.allProperties:{p|<p.name>}; separator=", "> });
}
public boolean <cmd.name>(<cmd.allProperties:parameter(); separator=", "><if(cmd.allProperties)>, <endif>Consumer\<JsonWrapper\> resultHandler) {
    return this.delegate.sendCommandIfRendered("<cmd.name>", new Object[] { <cmd.allProperties:{p|<p.name>}; separator=", "> }, resultHandler);
}
>>

toggleEventMethod(e) ::= <<
public void toggle<e.name; format="cap">Event(boolean enabled) {
    this.delegate.toggleEvent("<e.name>", enabled);
}
>>

eventMethodInvoker(c) ::= <<
<javaFilePrelude(c.packageName)>

<c.effectiveJavaImports:{im|import <im.javaPackageName>.<im.name>;}; separator="\n">
import java.lang.reflect.Method;
import org.teamapps.projector.clientobject.AbstractClientObjectEventMethodInvoker;
import java.util.function.Function;

public class <c.name>EventMethodInvoker extends AbstractClientObjectEventMethodInvoker {

	private static final org.slf4j.Logger LOGGER = org.slf4j.LoggerFactory.getLogger(java.lang.invoke.MethodHandles.lookup().lookupClass());

	public <c.name>EventMethodInvoker(Object targetObject) {
		super(targetObject);
	}

	@Override
	protected void invokeHandlerMethod(Method method, String name, JsonWrapper eventObject) throws Exception {
		switch (name) {
		    <c.allEvents:{e|case "<e.name>" -> <eventMethodInvocation(e)>}; separator="\n">
			default -> LOGGER.warn("No information on how to invoke this event handler method: {}", method.getName());
		}
	}
}
>>

eventMethodInvocation(e) ::= <<
<if(e.hasNoParameters)>
method.invoke(targetObject);
<elseif(e.hasOneParameter)>
method.invoke(targetObject, eventObject.as(<e.declaringClass.name>.<e.javaClassName>Wrapper::new).<if(e.parameters.first.type.boolean)>is<else>get<endif><e.parameters.first.name; format="cap">());
<else>
method.invoke(targetObject, eventObject.as(<e.declaringClass.name>.<e.javaClassName>Wrapper::new));
<endif>
>>

queryMethodInvoker(c) ::= <<
<javaFilePrelude(c.packageName)>

<c.effectiveJavaImports:{im|import <im.javaPackageName>.<im.name>;}; separator="\n">
import java.lang.reflect.Method;
import org.teamapps.projector.clientobject.AbstractClientObjectQueryMethodInvoker;
import java.util.function.Function;

public class <c.name>QueryMethodInvoker extends AbstractClientObjectQueryMethodInvoker {

	private static final org.slf4j.Logger LOGGER = org.slf4j.LoggerFactory.getLogger(java.lang.invoke.MethodHandles.lookup().lookupClass());

	public <c.name>QueryMethodInvoker(Object targetObject) {
		super(targetObject);
	}

	@Override
	protected Object invokeHandlerMethod(Method method, String name, List\<JsonWrapper> parameters) throws Exception {
	    <if(c.allQueries)>
		return switch (name) {
		    <c.allQueries:{e|case "<e.name>" -> method.invoke(targetObject<if(e.parameters)>, <endif><e.parameters:queryMethodParameterExtractor(i0); separator=", ">);}; separator="\n">
			default -> throw new UnsupportedOperationException("Unknown query name: " + method.getName());
		};
		<else>
		throw new UnsupportedOperationException("Unknown query name: " + method.getName());
		<endif>
	}
}
>>

queryMethodParameterExtractor(p, index) ::= <<
    ((Function\<JsonNode, <if(p.type.isDtoClassOrInterface)><p.type.javaJsonWrapperTypeString><else><p.type.javaNonPrimitiveTypeString><endif>\>) (node) -> {
        <wrapperPropertyValueExtractor(p.type, "node")>
    }).apply(parameters.get(<index>).getJsonNode())
>>

eventHandlerInterface(c) ::= <<
<javaFilePrelude(c.packageName)>

<c.effectiveJavaImports:{im|import <im.javaPackageName>.<im.name>;}; separator="\n">
import java.lang.reflect.Method;
import org.teamapps.projector.clientobject.AbstractClientObjectEventMethodInvoker;
import org.teamapps.projector.clientobject.ClientMessageHandler;
import java.util.function.BiFunction;

public interface <c.name>EventHandler <if(!c.abstract)>extends ClientMessageHandler<endif> {

<if(!c.abstract)>
	@Override
	default void handleEvent(String name, JsonWrapper eventObject) {
		new <c.name>EventMethodInvoker(this).handleEvent(name, eventObject);
	}

    @Override
    default Object handleQuery(String name, List\<JsonWrapper\> params) {
        return new <c.name>QueryMethodInvoker(this).handleQuery(name, params);
    }
<endif>

    <c.allEvents:eventMethodStub(); separator="\n">

    <c.allQueries:queryMethodStub(); separator="\n">

}
>>

eventMethodStub(e) ::= <<
void handle<e.name; format="cap">(<if(e.hasOneParameter)><e.parameters.first.type.javaJsonWrapperTypeString> <e.parameters.first.name><elseif(e.hasMultipleParameters)><e.declaringClass.name>.<e.name; format="cap">EventWrapper event<endif>);
>>

queryMethodStub(q) ::= <<
<q.returnType.javaTypeString> handle<q.name; format="cap">(<q.parameters:{p|<p.type.javaJsonWrapperTypeString> <p.name>}; separator=", ">);
>>