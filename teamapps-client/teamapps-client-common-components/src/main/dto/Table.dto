/*-
 * ========================LICENSE_START=================================
 * TeamApps
 * ---
 * Copyright (C) 2014 - 2022 TeamApps.org
 * ---
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =========================LICENSE_END==================================
 */
package org.teamapps.dto;

import Component from "teamapps-client-core":org.teamapps.dto;

enum SortDirection {
	ASC, DESC
}

class TableColumn {
	required String propertyName;
	required String icon;
	required String title;
	required Field* field;
	int minWidth;
	int defaultWidth;
	int maxWidth;
	boolean sortable;
	boolean resizeable;
	boolean visible;
	boolean hiddenIfOnlyEmptyCellsVisible;
	List<FieldMessage> messages;
	TextAlignment headerAlignment;
}

class Table extends AbstractInfiniteListComponent {
	required List<TableColumn> columns;

	boolean displayAsList; // list has no cell borders, table has. selection policy: list = row selection, table = cell selection
	boolean forceFitWidth; //if true, force the widths of all columns to fit into the available space of the list
	int rowHeight;
	boolean stripedRows;
	String stripedRowColorEven;
	String stripedRowColorOdd;
	boolean hideHeaders; //if true, do not show any headers
	boolean allowMultiRowSelection;
	String selectionColor; // null = default color
	int rowBorderWidth; // even in list mode! the border will be there but transparent!
	String rowBorderColor;

	boolean showRowCheckBoxes; //if true, show check boxes on the left
	boolean showNumbering; //if true, show numbering on the left
	boolean textSelectionEnabled;

	String sortField; //if available the table is initially sorted by this field
	SortDirection sortDirection;

	boolean editable; //only valid for tables

	boolean treeMode; //if true, use the parent id property of record to display the table as tree
	String indentedColumnName; // if set, indent this column depending on the depth in the data hierarchy
	int indentation; // in pixels

	SelectionFrame selectionFrame;

	boolean contextMenuEnabled;

	command clearTable();
	command updateData(int startIndex, List<Integer> recordIds, List<TableClientRecord> newRecords, int totalNumberOfRecords);
	command setSorting(String sortField, SortDirection sortDirection);
    command setCellValue(int recordId, String columnPropertyName, Object value);
	command markTableField(int recordId, String columnPropertyName, boolean mark); //mark or unmark the field to indicate errors or missing data
	command clearAllFieldMarkings();
	command setRecordBold(int recordId, boolean bold); //TODO
	command selectRecords(List<Integer> recordIds, boolean scrollToFirstRecord);
	command selectRows(List<Integer> rowIndexes, boolean scrollToFirstRowIndex);
	command editCellIfAvailable(int recordId, String propertyName);
	command cancelEditingCell(int recordId, String propertyName);
	command focusCell(int recordId, String columnPropertyName);
    command setSingleCellMessages(int recordId, String columnPropertyName, List<FieldMessage> messages);
    command clearAllCellMessages();
    command setColumnMessages(String columnPropertyName, List<FieldMessage> messages);
    command addColumns(List<TableColumn> column, int index);
    command removeColumns(List<String> columnName);
    command setColumnVisibility(String columnPropertyName, boolean visible);
	command setContextMenuContent(int requestId, Component* component);
	command closeContextMenu(int requestId);

	event cellClicked(int recordId, String columnPropertyName);
	event cellEditingStarted(int recordId, String columnPropertyName, Object currentValue);
	event cellEditingStopped(int recordId, String columnPropertyName);
	event cellValueChanged(int recordId, String columnPropertyName, Object value);
	event rowsSelected(List<Integer> recordIds);
	event sortingChanged(String sortField, SortDirection sortDirection); // sent when the user clicks on a sortable header column
	event contextMenuRequested(int requestId, int recordId);

	event fieldOrderChange(String columnPropertyName, int position); //zero based
	event columnSizeChange(String columnPropertyName, int size);

	// =========== header/footer row ("outerRow") ===========
	boolean showHeaderRow;
    int headerRowBorderWidth; // even in list mode! the border will be there but transparent!
    String headerRowBorderColor;
    int headerRowHeight;
    String headerRowBackgroundColor;
    Dictionary<Field*> headerRowFields;

	boolean showFooterRow;
    int footerRowBorderWidth; // even in list mode! the border will be there but transparent!
    String footerRowBorderColor;
    int footerRowHeight;
    String footerRowBackgroundColor;
    Dictionary<Field*> footerRowFields;
}

@TypeScriptFactory
class TableDataRequest {
	required int startIndex;
	required int length;
	required String sortField;
	required SortDirection sortDirection;
}

class TableCellMessages {
	required int recordId;
	required Dictionary<List<FieldMessage>> messages;
}

class SelectionFrame {
	String color;
	int borderWidth;
	int animationDuration; // ms
	int glowingWidth;
	int shadowWidth;
	boolean fullRow;
}

class TableClientRecord extends IdentifiableClientRecord {
	Dictionary<List<FieldMessage>> messages;
	List<String> markings;
	boolean selected;
	boolean bold;
}
