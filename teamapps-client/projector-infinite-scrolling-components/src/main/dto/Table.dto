/*-
 * ========================LICENSE_START=================================
 * TeamApps
 * ---
 * Copyright (C) 2014 - 2022 TeamApps.org
 * ---
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =========================LICENSE_END==================================
 */
package "projector-infinite-scrolling-components":org.teamapps.projector.components.infinitescroll.dto;

import org.teamapps.projector.dto.Component;
import org.teamapps.projector.dto.IdentifiableClientRecord;
import org.teamapps.projector.dto.AbstractField;
import org.teamapps.projector.dto.FieldMessage;
import org.teamapps.projector.dto.TextAlignment;

enum SortDirection {
	ASC, DESC
}

class TableColumn {
	required String propertyName;
	required String icon;
	required String title;
	required AbstractField* field;
	int minWidth;
	int defaultWidth;
	int maxWidth;
	boolean sortable;
	boolean resizeable;
	boolean visible;
	boolean hiddenIfOnlyEmptyCellsVisible;
	List<FieldMessage> messages;
	TextAlignment headerAlignment;
}

enum TableDisplayStyle {
	TABLE, LIST;
}

class Table extends AbstractInfiniteListComponent {
	required List<TableColumn> columns;

	TableDisplayStyle displayStyle;
	boolean forceFitWidth; //if true, force the widths of all columns to fit into the available space of the list
	int rowHeight;
	boolean stripedRowsEnabled;
	String rowColor;
	String stripedRowColorOdd;
	boolean columnHeadersVisible; //if false, do not show any headers
	boolean multiRowSelectionEnabled;
	String selectionColor; // null = default color
	int rowBorderWidth; // even in list mode! the border will be there but transparent!
	String rowBorderColor;

	boolean rowCheckBoxesEnabled; //if true, show check boxes on the left
	boolean numberingColumnEnabled; //if true, show numbering on the left
	boolean textSelectionEnabled;

	String sortField; //if available the table is initially sorted by this field
	SortDirection sortDirection;

	boolean editable; //only valid for tables

	SelectionFrame selectionFrame;

	boolean contextMenuEnabled;

    // =========== header/footer row ("outerRow") ===========
    boolean headerFieldsRowEnabled;
    int headerFieldsRowBorderWidth; // even in list mode! the border will be there but transparent!
    String headerFieldsRowBorderColor;
    int headerFieldsRowHeight;
    String headerFieldsRowBackgroundColor;
    mutable Dictionary<AbstractField*> headerFields;

    boolean footerFieldsRowEnabled;
    int footerFieldsRowBorderWidth; // even in list mode! the border will be there but transparent!
    String footerFieldsRowBorderColor;
    int footerFieldsRowHeight;
    String footerFieldsRowBackgroundColor;
    mutable Dictionary<AbstractField*> footerFields;

    command setHeaderRowField(String columnName, AbstractField* field);
    command setFooterRowField(String columnName, AbstractField* field);

	command clearTable();
	command updateData(int startIndex, List<Integer> recordIds, List<TableClientRecord> newRecords, int totalNumberOfRecords);
	command setSorting(String sortField, SortDirection sortDirection);
    command setCellValue(int recordId, String columnPropertyName, Object value);
	command markTableField(int recordId, String columnPropertyName, boolean mark); //mark or unmark the field to indicate errors or missing data
	command clearAllFieldMarkings();
	command setRecordBold(int recordId, boolean bold); //TODO
	command selectRecords(List<Integer> recordIds, boolean scrollToFirstRecord);
	command selectRows(List<Integer> rowIndexes, boolean scrollToFirstRowIndex);
	command editCellIfAvailable(int recordId, String propertyName);
	command cancelEditingCell(int recordId, String propertyName);
	command focusCell(int recordId, String columnPropertyName);
    command setSingleCellMessages(int recordId, String columnPropertyName, List<FieldMessage> messages);
    command clearAllCellMessages();
    command setColumnMessages(String columnPropertyName, List<FieldMessage> messages);
    command addColumns(List<TableColumn> column, int index);
    command removeColumns(List<String> columnName);
    command setColumnVisibility(String columnPropertyName, boolean visible);
	command setContextMenuContent(int requestId, Component* component);
	command closeContextMenu(int requestId);

	event cellClicked(int recordId, String columnPropertyName);
	event cellEditingStarted(int recordId, String columnPropertyName, Object currentValue);
	event cellEditingStopped(int recordId, String columnPropertyName);
	event cellValueChanged(int recordId, String columnPropertyName, Object value);
	event rowsSelected(List<Integer> recordIds);
	event sortingChanged(String sortField, SortDirection sortDirection); // sent when the user clicks on a sortable header column
	event contextMenuRequested(int requestId, int recordId);

	event fieldOrderChange(String columnPropertyName, int position); //zero based
	event columnSizeChange(String columnPropertyName, int size);
}

@TypeScriptFactory
class TableDataRequest {
	required int startIndex;
	required int length;
	required String sortField;
	required SortDirection sortDirection;
}

class TableCellMessages {
	required int recordId;
	required Dictionary<List<FieldMessage>> messages;
}

class SelectionFrame {
	String color;
	int borderWidth;
	int animationDuration; // ms
	int glowingWidth;
	int shadowWidth;
	boolean fullRow;
}

class TableClientRecord extends IdentifiableClientRecord {
	Dictionary<List<FieldMessage>> messages;
	List<String> markings;
	boolean selected;
	boolean bold;
}
